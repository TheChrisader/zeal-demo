import { createHash } from "crypto";

export interface SlugOptions {
  maxLength?: number;
  separator?: string;
  hashLength?: number;
  lowercase?: boolean;
}

export class SlugGenerator {
  private readonly defaultOptions: Required<SlugOptions> = {
    maxLength: 75,
    separator: "-",
    hashLength: 5,
    lowercase: true,
  };

  private static counter = 0;

  /**
   * Generates a unique, URL-safe slug from the given string
   * @param input - The string to convert to a slug
   * @param options - Configuration options for slug generation
   * @returns A unique, URL-safe slug
   * @throws Error if input is empty or invalid
   */
  public generate(input: string, options: SlugOptions = {}): string {
    if (!input || typeof input !== "string") {
      throw new Error("Input must be a non-empty string");
    }

    const opts = { ...this.defaultOptions, ...options };

    let slug = input
      .split("")
      .map((char) => (opts.lowercase ? char.toLowerCase() : char))
      .join("")
      .replace(/\s+/g, opts.separator)
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(new RegExp(`[^a-zA-Z0-9${opts.separator}]`, "g"), opts.separator)
      .replace(new RegExp(`${opts.separator}+`, "g"), opts.separator)
      .replace(new RegExp(`^${opts.separator}+|${opts.separator}+$`, "g"), "");

    const hash = this.generateHash(input, opts.hashLength);

    const maxBaseLength = opts.maxLength - opts.hashLength - 1;
    if (slug.length > maxBaseLength) {
      const lastSeparatorIndex = slug.lastIndexOf(
        opts.separator,
        maxBaseLength,
      );
      slug = slug.substring(
        0,
        lastSeparatorIndex > 0 ? lastSeparatorIndex : maxBaseLength,
      );
    }

    return `${slug}${opts.separator}${hash}`;
  }

  /**
   * Generates a unique hash for the given input
   * @param input - String to hash
   * @param length - Desired length of the hash
   * @returns URL-safe hash string
   */
  private generateHash(input: string, length: number): string {
    SlugGenerator.counter =
      (SlugGenerator.counter + 1) % Number.MAX_SAFE_INTEGER;

    const timestamp = Date.now().toString();
    const data = `${input}${timestamp}${SlugGenerator.counter}${Math.random()}`;

    return createHash("sha256")
      .update(data)
      .digest("base64")
      .replace(/[+/=]/g, "")
      .substring(0, length);
  }

  /**
   * Validates if a string is a valid slug generated by this generator
   * @param slug - The slug to validate
   * @param options - The options used to generate the slug
   * @returns boolean indicating if the slug is valid
   */
  public isValid(slug: string, options: SlugOptions = {}): boolean {
    const opts = { ...this.defaultOptions, ...options };
    const pattern = new RegExp(
      `^[a-zA-Z0-9${opts.separator}]+${opts.separator}[a-zA-Z0-9]{${opts.hashLength}}$`,
    );
    return pattern.test(slug);
  }
}

// Example usage:
/*
const slugGenerator = new SlugGenerator();

// Basic usage
const slug1 = slugGenerator.generate('Hello World'); // "hello-world-x7y9z"

// With custom options
const slug2 = slugGenerator.generate('Hello World', {
  maxLength: 50,
  separator: '_',
  hashLength: 6,
  lowercase: false
}); // "Hello_World_x7y9z2"

// Validation
console.log(slugGenerator.isValid(slug1)); // true
*/
